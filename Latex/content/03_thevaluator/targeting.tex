%
% Zielbestimmungen
% Abschlussarbeit (Bachelor)
%
% Thema: Erstellung einer Browser Extension zur Usability Evaluierung von beliebigen Web-Applikationen über Heatmaps.
% Betreuer 1: Prof. Dr. Targo Pavlista
% Betreuer 2: Siamak Haschemi
%
% @author Christian Bromann <contact@christian-bromann.com>
%

\newglossaryentry{DOM}{name=DOM, description={Entspricht dem \textit{Document-Object-Model} und bezeichnet das HTML Gerüst einer Webseite}}
\hyphenation{Script-es}

\section{Zielbestimmungen}

Das Ziel, ein Tool zu entwickeln, welches die Usability einer Webseite untersuchen soll, setzt nicht automatisch dessen Funktionsweise und Handhabung voraus. Es müssen Entscheidungen getroffen werden, die richtungsweisend dafür sind, wie das Tool später benutzt wird. Diese Entscheidungen müssen wohl überlegt sein, da Usability auch sehr entscheidend für eine Software ist, die die Usability analysiert. Die Definition einer Zielgruppe ist dabei ein sehr wichtiger Faktor in der Entscheidungsfindung. \textit{thEvaluator} ist dafür entwickelt worden, das Usability-Testing einfach zu gestalten. Es soll für möglichst viele Personen benutzbar sein und erfordert daher kaum Erfahrungen im Programmieren. Zudem soll die Auswertung ebenfalls einfach gehalten werden, sodass die Benutzer des Tools keinen Usability-Experten für die Analyse konsultieren müssen. Die Frage, ob Besucher eine Webseite richtig benutzen und schnell zu ihrem Ziel finden, kann hierbei durch klare und aussagekräftige Visualisierungen der Daten schnell beantwortet werden.\\
\\
Je komplexer eine Programm wird, desto mehr Konfigurationen gibt es, die der User beachten muss. Gute Software zeichnet sich dadurch aus, dass sie zwar viele Konfigurationen anbietet, jedoch nur wenige vom Benutzer wirklich benötigt, um zu funktionieren. Um die einfache und schnelle Nutzung des \textit{thEvaluator} Tools zu bewahren, sollte dieses deshalb ohne große Einrichtungsprozesse nutzbar sein. Eine Einschränkung der Funktionalität oder die teilweise Verkomplizierung der Nutzung muss dabei manchmal in Kauf genommen werden. Diese Konzeptionsfragen sind vom Entwickler oder Entwicklerteam jedes Mal neu zu evaluieren.\\
\\
Die meisten der bisherigen Usability-Tools verlangen vom Nutzer die Einbindung eines Scripts in die zu testende Seite. Diese Codeschnipsel binden meist eine externe Bibliothek ein, die sich darum kümmert, jegliche Aktionen und Events auf der Seite zu erfassen und an den Server zu schicken. Der Vorteil dieses Verfahrens ist, dass die Testuser einfach nur die Seite besuchen müssen, um am Test teilzunehmen. \textit{thEvaluator} verfolgt hier einen anderen Ansatz. Es erfordert ein Browser Plugin, welches sich um die Datenaufzeichnung kümmert und die Aufgaben des Testcases in die Seite einblendet. Dadurch sind keine Programmierkenntnisse nötig, um das Tool nutzen zu können. Zudem ermöglicht es das Testen jeder beliebigen Seite im Web. Unzählige Möglichkeiten eröffnen sich dadurch, da nicht nur die eigene Seite analysiert und ausgewertet werden kann, sondern auch die der Konkurrenz. Das Tool ist somit universell einsetzbar. Großer Nachteil an diesem Verfahren ist, dass Testuser dazu aufgefordert werden, sich fremde Software auf ihrem System zu installieren. Dies schreckt im ersten Moment viele ab, was dazu führt, dass weniger Personen an dem Test teilnehmen. Da die Nutzung von Browser-Erweiterungen heutzutage jedoch weit verbreitet ist und die Installation von den Herstellern sehr vereinfacht wurde, ist der Nachteil bei Weitem nicht so groß wie die Möglichkeiten, die durch den universellen Einsatz hervortreten.\\
\\
Eine weitere wichtige Konzeptionsentscheidung ist der Einsatz von aufgabengetriebenen Testcases. Tasks haben einen enormen Einfluss auf Usability-Tests. Sie lenken die Besucher auf bestimmte Wege und manipulieren somit gewollt das Userverhalten. Tests können dadurch bestimmte Besucherintentionen simulieren oder sich auf gezielte Bereiche einer Webseite konzentrieren. Nach Hertzum und Jacobson offenbaren verschiedene Typen von Aufgaben unterschiedliche Arten von Usability-Problemen, wogegen strukturierte Aufgaben lediglich Oberfläche Schwachstellen aufdecken \cite{anzahlTestpersonen}. Die Möglichkeiten an Aufgaben sind bei \textit{thEvaluator} daher sehr groß. Ob es ein Klick auf einen Link ist oder das Öffnen des Contextmenüs, jedes vom Browser erzeugte Event kann durch das Tool abgefangen werden. Würde es auf die Aufgaben verzichten und lediglich das Verhalten der alltäglich kommenden Besucher aufzeichnen, so hätte man zwar ein natürlicheres Abbild der Seitennutzung, könnte die einzelnen Intentionen der Besucher jedoch kaum nachvollziehen und dadurch nicht genau erfassen, ob eine Handlung bewusst und gewollt oder unbeabsichtigt war.\\
\\
\phantomsection
\label{events}
Der Zeitpunkt, wann eine Aufgabe durch den User erfüllt wurde, ist klar zu definieren. Die Browser Extension muss dabei durch die Webseite ein Signal bekommen, wann dies geschehen ist. Diese Signale werden im Web als Events bezeichnet. Die Event-Übertragung kann dabei entweder programmatisch durch die Webseite selber erfolgen oder vom Browser übernommen werden. Ersteres hat den Vorteil, dass der Zeitpunkt und die Aktion des Nutzers besser durch interne Scripts abgefangen werden kann und dadurch individuellere Aufgaben möglich sind. Dies würde aber zusätzlichen Aufwand für die Nutzung des Tools voraussetzen, da dies erst in die Webseite implementiert werden muss. Zusätzlich wäre man nicht mehr in der Lage, jede beliebige Webseite testen zu lassen, da das Ändern von Code fremder Webseiten nicht möglich ist. \textit{thEvaluator} ist jedoch darauf ausgelegt, möglichst jede Seite testen zu können und dies ohne eine Änderung am Code. Bei der Erstellung eines Tasks benötigt es deshalb vom User ein Ziel-Event, um eine Aufgabe zu lösen. Dieses Ziel-Event wird durch zwei Komponenten definiert. Zum Einen den Typ des Events und zum Anderen das \Gls{DOM}-Element, welches das Event erzeugen soll. Mit diesen Informationen kann die \textit{thEvaluator}-Extension bei jedem Seitenaufruf einen Listener registrieren, der darauf reagiert, wenn der Browser das definierte Event sendet. Ein mögliches Ziel-Event könnte z.B. der Klick auf ein \Gls{DOM}-Element vom Typ Link sein, welcher als Ziel eine bestimmte Seite attributiert. Diese Art der Zieldefinierung schränkt zwar die Individualität der Aufgaben ein, da z.B. keine Eingabeevaluierungen möglich sind oder auf bestimmte Seitenzustände nicht reagiert werden kann, dennoch ermöglicht es das Realisieren von vielen grundlegenden Aufgaben, wie das Finden von Informationen auf bestimmten Unterseiten. Zudem ist es möglich, die Ziel-Events trotzdem in die Seite zu implementieren und dadurch die Aufgaben für den Test zu individualisieren.